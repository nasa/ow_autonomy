// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// This plan demonstrates aspects of the Fault Dependencies framework,
// described in the OceanWATERS user guide at
// https://github.com/nasa/ow_simulator/wiki/Autonomy, and requires
// its use.  In particular you must start the executive as follows:
//
//   roslaunch ow_plexil ow_exec.launch fault_dependencies_file:="FaultDependenciesModel.xml"
//
// This plan has a main action and a backup action, only one of which
// should operate at a time, depending on operability (fault) status.
//
// The main action is that the antenna will pan, tilt and then take a
// picture, repeatedly.  If the Pan Fault is active it will only Tilt
// and Take a Picture. If the Tilt Fault is active it will only Pan
// and take a picture. If the Camera Fault is active, an image capture
// will still be attempted, and the final result shown.  If and only
// if both Pan and Tilt are inoperable, the backup action will begin.

// The backup action is to unstow/stow the arm repeatedly.  Any arm
// fault will pause the backup action until the faults are cleared.
// Whenever the antenna is operable (pan or tilt), the backup action
// will stop, and main action will resume.

// Note that it may take up to 20 seconds to see the expected reaction
// to fault injection and clearing, because operations are invoked in
// a blocking fashion (via SynchronousCommand) and need to complete.
// At present PLEXIL does not have a finer degree of control over ROS
// actions -- they must run to completion once started.


#include "ow-interface.h"

FaultDependenciesDemo: UncheckedSequence
{
  Real NewPanAngle = 0;
  Real NewTiltAngle = 20;
  Real Count = 0;

  log_info ("Starting FaultDependenciesDemo plan...");

  Run: Concurrence
  {
    MainAction:
    {
      RepeatCondition true;

      PanTiltPattern: UncheckedSequence
      {
        //        StartCondition Lookup(IsOperable("Pan")) || Lookup(IsOperable("Tilt"));
        //        Invariant Lookup(IsOperable("Pan")) || Lookup(IsOperable("Tilt"));

        NewPanAngle = (Lookup(PanDegrees) + 15) mod 360;

        if NewPanAngle > 180 NewPanAngle = NewPanAngle - 360;

        if Count % 2 == 0 NewTiltAngle = 10;
        else NewTiltAngle = -10;
        endif;

        Count = Count + 1;

        if Lookup(IsOperable("Pan")) && Lookup(IsOperable("Tilt")) {
          log_info("Panning and Tilting...");
          LibraryCall PanTiltMoveJoints (PanDegrees=NewPanAngle,
                                         TiltDegrees=NewTiltAngle);
        }
        elseif Lookup(IsOperable("Tilt")){
          log_info("Pan Inoperable, executing Tilt only...");
          LibraryCall Tilt (Degrees=NewTiltAngle);
        }
        elseif Lookup(IsOperable("Pan")){
          log_info("Tilt Inoperable, executing Pan only...");
          LibraryCall Pan (Degrees=NewPanAngle);
        }
        else log_info("Tilt and Pan inoperable.");
        endif;

        if Lookup(IsOperable("CameraCapture")) {
          log_info("Taking Picture...");
          LibraryCall CameraCapture();
        }
        else {
          log_info("Camera is faulted, attempting picture to clear fault...");
          LibraryCall CameraCapture();
          if Lookup(IsOperable("CameraCapture")) {
            log_info("Camera now Operable, picture taken");
          }
          else log_warning("Camera Is Inoperable, no picture taken.");
        }
        endif;
      }
      Wait 1; // Gives BackupAction a chance to run.
    }

    BackupAction:
    {
      RepeatCondition true;
      StowingPattern: UncheckedSequence
      {
        //        StartCondition (!Lookup(IsOperable("Tilt")) &&
        //                        !Lookup(IsOperable("Pan")) &&
        //                        Lookup(IsOperable("Arm")));
        //        Invariant (Lookup(IsOperable("Arm")) &&
        //                   !Lookup(IsOperable("Pan")) &&
        //                   !Lookup(IsOperable("Tilt")));

        if Lookup(IsOperable("ArmUnstow")) LibraryCall ArmUnstow();
        else log_warning("ArmUnstow Is Inoperable, action skipped.");
        endif;

        if Lookup(IsOperable("ArmStow")) LibraryCall ArmStow();
        else log_warning("ArmStow Is Inoperable, action skipped.");
        endif;
      }
      Wait 1; // Gives MainAction a chance to run.
    }
  }
}
